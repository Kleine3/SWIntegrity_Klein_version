import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.HashSet;

public class AdaDirectoryTraversalVulnerability implements Vulnerability {

    @Override
    public List<Integer> run(Analyzer ana) {
        AdaAnalyzer aana = (AdaAnalyzer) ana;
        HashSet<Integer> lineNumbers = new HashSet<>();
        /*
         * Case 1: ensuring relative path traversal cannot be used maliciously.
         * If the programmer is checking for and removing the suspicious string "../" or "..\" (a blacklisting technique)
         * then they are most likely not using a whitelist, which is more secure.
         * Even if "../" or "..\" removal is somehow being used in tandem with a whitelist, the string removal is easily circumvented
         * by an attacker inputting the string ".../...//", which resolves to "../". Thus, the string removal is unnecessary.
         */
        String contents = aana.getFileContents();
        String[] temp = contents.split(" ");
        Map<Integer, Integer> stl = new HashMap<>(aana.getSymbolToLine());

        for(int i=0; i<temp.length-2; i++){
            if(temp[i].equals(".") && temp[i+1].equals(".") && temp[i+2].equals("/")) {
                lineNumbers.add(contents.indexOf(temp[i]));
            }
        }

        /*
         * Case 2: ensuring absolute path traversal cannot be used maliciously
         * If the programmer is checking user input for "/" or "\" to prevent the user from specifying
         * an arbitrary directory (a blacklisting technique) then they are likely not using a whitelist, which is more secure.
         */
        //checking if "/" or "\" is being specifically sought out as a String, ensuring we're not catching other slashes that may be in the code
        if(aana.getLiterals().contains("/") || aana.getLiterals().contains("\\")){
            for(int i=0; i<temp.length; i++){
                if(temp[i].contains("/") || temp[i].contains("\\")){
                    lineNumbers.add(stl.get(i));
                }
            }
        }
        return new ArrayList<Integer>(lineNumbers);
    }
}