import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;



public class AdaDanglingPointerVulnerability implements Vulnerability {

	@Override
	public List<Integer> run(Analyzer ana) {
		AdaAnalyzer aana=(AdaAnalyzer)ana;
		//case 1: access type variables that have not been freed still point to another access type variable that was freed
				Pattern deallocatorMethod = Pattern.compile("procedure \\S{1,} is new Ada.Unchecked_Deallocation");
				ArrayList<String> methodList = new ArrayList<>();
				HashSet<String> dangerousVariables = new HashSet<>();
				HashSet<AdaAnalyzer.Variable> danglers = new HashSet<>();
				Matcher matcher = deallocatorMethod.matcher(aana.rawCode);
				while(matcher.find()){
					methodList.add(matcher.group().substring(10, aana.rawCode.indexOf("is new", matcher.start())-1));
				}
				for(String m : methodList) {
					Pattern methodCall = Pattern.compile(m + "(\\S{1,})");
					Matcher mat = methodCall.matcher(aana.rawCode);
					while(mat.find()){
						String found = mat.group();
						dangerousVariables.add(found.substring(m.length() + 1, found.lastIndexOf(")")));
					}
				}
				for(String v : dangerousVariables){
					for(AdaAnalyzer.Variable va : aana.variables.values()){
						Pattern assign = Pattern.compile(va.getName() + "\\s*:\\s*=\\s*" + v);
						Matcher mm = assign.matcher(aana.rawCode);
						if(mm.find() && !dangerousVariables.contains(va.getName())){ //if var := myFunction is called, and myFunction returns an access type, this won't catch it
							danglers.add(va);
						}
					}
				}
				//case 2: access type variable is assigned to a local variable that has become out of scope, and the access type variable is not reassigned to something else
				int accessScope = 0;
				int localVariableScope = 0;
				String maybeVariable = "";
				Pattern numeric = Pattern.compile("[0-9]{1,}");
				Matcher mt;
				for(AdaAnalyzer.Variable v : aana.variables.values()){
					if (aana.accessTypes.contains(v.getType())) { //the variable is an access type
						mt = numeric.matcher(v.getScope());
						while (mt.find()) {
							if (mt.hitEnd()) {
								accessScope = Integer.parseInt(mt.group());
							}
						}
						Pattern assignment = Pattern.compile(v.getName() + "\\s*:\\s*=\\s*");
						Pattern value = Pattern.compile("\\S{1,};");
						Matcher mtch = assignment.matcher(aana.rawCode);
						Matcher cap = value.matcher(aana.rawCode);
						while(mtch.find()){
							if(cap.find(mtch.end())){
								maybeVariable = cap.group().substring(0, cap.group().length()-1);
								if(aana.variables.keySet().contains(maybeVariable)){
									mt = numeric.matcher(aana.variables.get(maybeVariable).getScope());
									while(mt.find()){
										if(mt.hitEnd()){
											localVariableScope = Integer.parseInt(mt.group());
										}
									}
									if(localVariableScope > accessScope){
										danglers.add(v);
									}
								}
							}
						}
					}
				}
				if(danglers.isEmpty()){
					System.out.println("No danger of dangling access types found.");
				}
				else{
					System.out.println("Danger of dangling access types:");
					for(AdaAnalyzer.Variable vari : danglers){
						System.out.println(vari.getName());
					}
				}
				LinkedList<Integer> lines=new LinkedList<>();
				Iterator<AdaAnalyzer.Variable> it=danglers.iterator();
				while(it.hasNext()) {
					lines.add(it.next().getLine());
				}
				return lines;
	}

}
